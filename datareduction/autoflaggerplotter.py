#!/usr/bin/env ParselTongue

# reads an Aips data file and plots a dynamic spectrum for all baselines
# on a single diagram
#
# changelog
# 07jul2010: reads in multiple IFs
#            reads in only every nth data point to speed up reading the data
#
# Apr 2012: major update, implementation of 'pieflag'-style amplitude flagging
#
# Enno Middelberg 2009

import sys
from AIPS import AIPS
from AIPSTask import AIPSTask, AIPSList
from AIPSData import AIPSUVData, AIPSImage, AIPSCat
from Wizardry.AIPSData import AIPSUVData as WizAIPSUVData
import numpy as n
import pylab as p
import matplotlib.cm as cm
import math as m
import cPickle
import time as tm
import os
from matplotlib.ticker import FuncFormatter
import pprocess
import optparse
#import vlbatasks


######################################
#
# evaluate the command line
#

parser=optparse.OptionParser()

parser.add_option('--i',       dest='aipsfile',   type='string',                        help='AIPS data file of the form userno.inname.inclass.indisk.inseq [no default]')
parser.add_option('--makeplot',dest='makeplot',   action='store_true',   default=False, help='Write hardcopy of plot to disk [default: %default]')
parser.add_option('--noint',   dest='noint',      action='store_true',   default=False, help='Skip interactive mode [default: %default]')
parser.add_option('--read',    dest='read',       type='int',    default=1,     help='Read only every nth data point [default: %default]')
parser.add_option('--minmax',  dest='minmax',     type='string', default='min,max',   help='Min/max of colour transfer function [default: determine from data]')
parser.add_option('--flagfile',dest='flagfile',   type='string', default='',          help='Filename to save flags in [default: aipsname.flag]')
parser.add_option('--usepickle',dest='usepickle', type='string', default='',          help='Use given pickle file (save to if not exist, read from if exist, default empty)')

(opts,args) = parser.parse_args()

#print opts, args, opts.aipsfile

if opts.aipsfile == None:
    parser.error('You must supply an "AIPSfile" string (form "userno.inname.inclass.indisk.inseq")')
AIPS.userno=int(opts.aipsfile.split('.')[0])
infile =opts.aipsfile.split('.')[1]
inclass=opts.aipsfile.split('.')[2]
indisk =int(opts.aipsfile.split('.')[3])
inseq  =int(opts.aipsfile.split('.')[4])
flagfile = opts.flagfile
if flagfile == '':
    flagfile = opts.aipsfile + '.flag'
print "\n Reading data from file/class/disk/seq %s.%s.%i.%i, user number %i" % \
      (infile, inclass, indisk, inseq, AIPS.userno)

# do we make a hardcopy?
if opts.makeplot:
    print " Storing a hardcopy in %s.montage.png" % flagfile

# do we go into interactive mode?
if opts.noint:
    print " Not going into interactive mode"


# read only every nth data point?
if opts.read>1:
    print " Reading every %i data point(s)" % opts.read

# generate the UVFLG file to which flags are appended later
now=tm.asctime(tm.localtime())
if os.path.exists(flagfile):
    print " File %s exists - appending new flags to it." % flagfile
    outfile=open(flagfile, 'a')
    outfile.write('!\n! Flags appended by dynspec-flagger.py on %s\n!\n' % now)
    outfile.close()
else:
    print " Creating %s to store the flags." % flagfile
    outfile=open(flagfile, 'w')
    outfile.write('! Flags generated by dynspec-flagger.py on %s\n' % now)
    outfile.write('opcode = \'FLAG\'\n')
    outfile.close()


#
#
########################################


# compute the median absolute difference of an array
def mad(array):
    med=n.median(array)
    mad=n.median(n.abs(array-med))
    return med, mad

# Function to convert seconds to hh:mm:ss.ss format, returns a string
def time2hms(seconds):
    h=int(seconds/3600)
    m=int(seconds % 3600)/60
    s=seconds-(h*3600)-(m*60)
    h=`h`
    m=`m`
    s="%4.2f" % s
    hms=h.zfill(2)+":"+m.zfill(2)+":"+s.zfill(4)
    return hms

# convert a fractional day into Aips format 
def time2aips(fracday):
    nsec=int(round(fracday*24*3600))
    dd=nsec/(24*3600)
    hh=(nsec-dd*24*3600)/3600
    mm=(nsec-dd*24*3600-hh*3600)/60
    ss=nsec-dd*24*3600-hh*3600-mm*60
    return '%02i,%02i,%02i,%02i' % (dd, hh, mm, ss)

# function to explain usage of interactive display
def printhelp():
    print """\n
 You have the following options for the interactive display:

 left click          - open up a window with an enlarged view of the selected subplot
 shift + left click  - flag the selected baseline
 right click         - flag all baselines to the antenna labelled \"Ant XX\"
 shift + right click - flag all baselines to the antenna labelled \"Bsl XX\"
 \n"""

# this makes meaningful x-axis tic labels
# see http://matplotlib.sourceforge.net/examples/pylab_examples/custom_ticker1.html
def xticlabels(y, pos):
    'The two args are the value and tick position'
    return '%1.3f' % ((reffreq+(x+refpix)*refinc)/1e9)

# this function evaluates the clicks on the plot
def onclick(event):

    # each plot is identified via a dictionary
    # the key is the subplot object
    selplt=plots[event.__dict__['inaxes']][0]
    selant=plots[event.__dict__['inaxes']][1]
    selbsl=plots[event.__dict__['inaxes']][2]
    selpol=plots[event.__dict__['inaxes']][3]
    
    # left click makes a new plot
    if event.__dict__['button']==1 and  event.__dict__['key']==None:
        zoom=p.figure()
        bslname="%i-%i" % (selant, selbsl)
        data=alldata[selpol][bslname]
        im = p.imshow(n.flipud(n.rot90(data[:,2:])), origin='lower', vmin=vmin, vmax=vmax, aspect='auto', interpolation='nearest')
        p.xlabel('Visibility number')
        p.ylabel('Channel number')
	#ax=p.gca()
	#formatter = FuncFormatter(xticlabels)
        #print formatter
	#ax.xaxis.set_major_formatter(formatter)
        p.title('Data on baseline %s' % bslname)
        p.show()

    # shift left click flags a baseline
    if event.__dict__['button']==1 and  event.__dict__['key']=='shift':
        outstring="antennas=%i baseline=%i stokes=\'%s\' reason=\'dynspec-flagger.py\' /" % (selant, selbsl, polnames[selpol])
        print outstring
        outfile=open(flagfile, 'a')
        outfile.write('%s\n' % outstring)
        outfile.close()
        
    # right click flags an antenna
    if event.__dict__['button']==3 and  event.__dict__['key']==None:
        outstring="antennas=%i stokes=\'%s\' reason=\'dynspec-flagger.py\' /" % (selant, polnames[selpol])
        print outstring
        outfile=open(flagfile, 'a')
        outfile.write('%s\n' % outstring)
        outfile.close()

    # shift right click flags an antenna (from the baseline column)
    if event.__dict__['button']==3 and  event.__dict__['key']=='shift':
        outstring="antennas=%i stokes=\'%s\' reason=\'dynspec-flagger.py\' /" % (selbsl, polnames[selpol])
        print outstring
        outfile=open(flagfile, 'a')
        outfile.write('%s\n' % outstring)
        outfile.close()

# evaluate keyboard events
def on_key_event(event):

    # quit if q is pressed
    if event.__dict__['key']=='q':
        print " q pressed - exiting.\n"
        sys.exit(0)

    # print help if needed
    if event.__dict__['key']=='h':
        printhelp()

    # refresh the plot
    if event.__dict__['key']=='r':
        p.draw()

# flagging a la pieflag (Middelberg 2006, PASA, 23, 64)
def flagit(row):
    output=[]
    subdata, bsl, stokes=row
    ant1=bsl.split('-')[0]
    ant2=bsl.split('-')[1]
    stokes=polnames[stokes]

    output.append('\n Now flagging baseline %s, polarisation %s' % (bsl, stokes))

    # figure out which source IDs are on current baseline
    srcids=n.unique(subdata[:,1])
    a=' '.join(['%i ' % x for x in srcids])
    output.append(' Found the following source IDs: %s' % a)

    # create array which holds the flags: make a copy of data and set
    # amplitudes to zero, keep time and source information
    subdataflags=n.copy(subdata)
    subdataflags[:,2:]=0.0

    # loop over source and do 'amplitude-based flagging'
    for src in srcids:
        # determine median and mad for current source
        output.append(' Current source ID: %i' % src)
        output.append(' Number of visibilities: %i' % subdata[subdata[:,1]==src][:,2:].shape[0])
        refmed, refmad=mad(subdata[subdata[:,1]==src][:,2:])
        output.append(' Median, MAD: %.3e  %.3e' % (refmed, refmad))
        #
        # flag data
        subdataflags[:,2:][subdataflags[:,1]==src]=n.where(subdata[subdata[:,1]==src][:,2:]>refmed+ 7*refmad, 1.0, subdataflags[:,2:][subdataflags[:,1]==src])
        subdataflags[:,2:][subdataflags[:,1]==src]=n.where(subdata[subdata[:,1]==src][:,2:]>refmed+14*refmad, 2.0, subdataflags[:,2:][subdataflags[:,1]==src])

    convolvedflags=n.copy(subdataflags)

    # extend flags over short periods of time
    # loop over channels
    for x in range(2, subdataflags.shape[1]):
        # convolve with kernel, subtract 1 to set those regions to 0
        # where only a single flag was found
        shortconv=n.convolve(subdataflags[:,x], shortkernel, mode='same')-1
        # convolve result with kernel, clip to 0,1 for convenience
        shortconv=n.convolve(shortconv, shortkernel, mode='same').clip(0,1)
        convolvedflags[:,x]=shortconv

    # now smooth on longer timescale
    convolvedflags2=n.copy(convolvedflags)
    for x in range(2, subdataflags.shape[1]):
        # convolve with long kernel, subtract acceptable max and clip to 0,1
        # test if there is a sufficient number of visibilities
        if subdataflags.shape[0]>=longwidth:
            longconv=n.clip(n.convolve(convolvedflags[:,x], longkernel, mode='same')-longfrac*longwidth, 0, 1)
            longconv=n.convolve(longconv, longkernel, mode='same').clip(0,1)
        # if not, simply test the fraction of flagged data
        else:
            if convolvedflags[:,x].sum()/convolvedflags[:,x].size>longfrac:
                longconv=n.ones(convolvedflags[:,x].size)
            else:
                longconv=convolvedflags[:,x]
        # write flags back to convolvedflags
        convolvedflags2[:,x]=n.round(n.array(longconv + convolvedflags[:,x]).clip(0,1))

    flaggedfrac=convolvedflags2[:,2:].sum()/len(convolvedflags2[:,2:].flatten())
    output.append(' Flagged a fraction of %.2f' % flaggedfrac)

    # generate flagging commands
    commands=[]

    # set new FG table keywords using those of CL#1
    ### CL=uvdata.table('CL', 1)
    ### FG=uvdata.attach_table('FG', (uvdata.table_highver('AIPS FG')+1), no_term=CL.keywords['NO_TERM'])
    ### FG.keywords['NO_ANT'] = CL.keywords['NO_ANT']
    ### FG.keywords['NO_POL'] = CL.keywords['NO_POL']
    ### FG.keywords['NO_IF'] =  CL.keywords['NO_IF']
    ### CL.close()
    # loop over channels on this baselines
    for x in range(nif):
        for y in range(nchan):
            #print "Looping..."
            index=2+x*nchan+y
            # pad data with leading and trailing zero to make sure
            # start and stop times are recognised
            channeldata=n.r_[0, convolvedflags2[:,index], 0]
            # start/stop times are found by differenciating
            # consecutive numbers in flag array
            # in its single-argument form, n.where returns a
            # tuple, therefore a [0] index is needed to return a
            # list
            starttimes=n.where(n.diff(channeldata)== 1)[0]
            stoptimes =n.where(n.diff(channeldata)==-1)[0]
            if starttimes.size>0:
                # somethings wrong when unequal number of starttimes and stoptimes
                if len(starttimes)!=len(stoptimes):
                    print '\n\n ERROR: unequal number of start and stop times - aborting'
                    n.set_printoptions(threshold=n.nan)
                    print channeldata
                    print n.diff(channeldata)
                    print convolvedflags2[:,index]
                    sys.exit(1)
                # add/subtract 1s to/from end/start of region to
                # flag, to account for rounding errors along the
                # way
                for z in range(starttimes.size):
                    a=time2aips(convolvedflags2[starttimes[z]][0]-1.0/24.0/3600.0)
                    b=time2aips(convolvedflags2[stoptimes[z]-1][0]+1.0/24.0/3600.0)
                    outstring="antennas=%s baseline=%s stokes=\'%s\' bif=%i eif=%i bchan=%i echan=%i timerang=%s,%s reason=\'dynspec-flagger.py\' / \n" \
                               % (ant1, ant2, stokes, (x+1), (x+1), (y+1), (y+1), a, b)
                    ### flags={}
                    ### flags['chans']     =[y+1, y+1]
                    ### flags['ifs']       =[x+1, x+1]
                    ### flags['ants']      =[ant1, ant2]
                    ### flags['time_range']=[convolvedflags2[starttimes[z]][0]-1.0/24.0/3600.0, convolvedflags2[stoptimes[z]-1][0]+1.0/24.0/3600.0]
                    ### flags['freq_id']   =0
                    ### flags['reason']    ='dynspec-flagger.py'
                    ### flags['source']    =0
                    ### flags['subarray']  =1
                    ### if pol==0:
                    ###     flags['pflags']=[1, 0, 0, 0]
                    ### else:
                    ###     flags['pflags']=[0, 0, 0, 1]
                    commands.append(outstring)
                    ### print flags
                    ### FG.append(flags)

    ### FG.close()

    # get min and max for plots
    if opts.minmax!='min,max':
        vmin=float(opts.minmax.split(',')[0])
        vmax=float(opts.minmax.split(',')[1])
    else:
        vmin=0
        vmax=1
    fig1=p.figure()
    ax1=p.subplot(4,1,1)
    p.imshow(n.flipud(n.rot90(subdata)), aspect='auto', interpolation='nearest', vmin=vmin, vmax=vmax, origin='lower')
    
    ax2=p.subplot(4,1,2, sharex=ax1, sharey=ax1)
    p.imshow(n.flipud(n.rot90(subdataflags)), aspect='auto', interpolation='nearest', vmin=vmin, vmax=vmax, origin='lower')
    
    ax3=p.subplot(4,1,3, sharex=ax1, sharey=ax1)
    p.imshow(n.flipud(n.rot90(convolvedflags)), aspect='auto', interpolation='nearest', vmin=vmin, vmax=vmax, origin='lower')
    
    ax4=p.subplot(4,1,4, sharex=ax1, sharey=ax1)
    p.imshow(n.flipud(n.rot90(convolvedflags2)), aspect='auto', interpolation='nearest', vmin=vmin, vmax=vmax, origin='lower')
    
    
    #for x in range(128):
    #    p.scatter(subdata[:,0], subdata[:,2+x], s=1)
    #ax=p.gca()
    #p.axhline(y=refmed)
    #p.axhline(y=refmed+7*refmad, color='red')
    #p.axhline(y=refmed+3*refmad)
    
    p.savefig('%s._bsl_%s_%s.png' % (flagfile, bsl, stokes))

    #if not opts.plotraw:
    #    subdata[:,2:]=n.where(convolvedflags2[:,2:]==1, 0, subdata[:,2:])

    return commands, output#, convolvedflags2, bsl, pol


# open up the Aips data file
uvdata=AIPSUVData(infile, inclass, indisk, inseq)
wizuvdata=WizAIPSUVData(infile, inclass, indisk, inseq)


# figure out how many plots to draw
nant=len(uvdata.antennas)
nx=nant
ny=nant
print " Number of stations is %i, going to draw %i x %i plots" % (nant, nx, ny)


# figure out number of channels
nchan=uvdata.header['naxis'][uvdata.header['ctype'].index('FREQ')]
print " Number of channels: %i" % nchan

# store frequency of reference channel and channel increment
reffreq=uvdata.header['crval'][uvdata.header['ctype'].index('FREQ')]
refinc=uvdata.header['cdelt'][uvdata.header['ctype'].index('FREQ')]
refpix=uvdata.header['crpix'][uvdata.header['ctype'].index('FREQ')]

# this could be needed to determine the frequencies very accurately
#refsign=cmp(refinc, 0.0)
#print "refsign=", refsign

# figure out number of IFs
if 'IF' in uvdata.header['ctype']:
    nif=uvdata.header['naxis'][uvdata.header['ctype'].index('IF')]
    print " Number of IFs: %i" % nif
else:
    print " Keyword IF not found in header, assuming number of IFs is 1"
    nif=1

# try to guess polarisation names
AN=uvdata.table('AN', 1)
maxannum = 0
for x in AN:
    polnames={0: 2*x['poltya'][0], 1: 2*x['poltyb'][0]}
    if x.nosta > maxannum:
        maxannum = x.nosta

print " Polarisation labels of last antenna in AN table are %s, %s, using this as plot labels" % (polnames[0], polnames[1])


# generate a dictionary of baselines
data_RR={}
data_LL={}
for x in range(1, maxannum):
    for y in range(x+1, maxannum+1):
        code="%i-%i" % (x,y)
        # data arrays can hold one value per channel, plus a timestamp
        # and a source ID
        data_RR[code]=n.zeros([0,nchan*nif+2])
        data_LL[code]=n.zeros([0,nchan*nif+2])


# read in the data
count=int(0)
if opts.usepickle=='' or not os.path.exists(opts.usepickle):
    for row in wizuvdata:
        if (count % opts.read)==0:
            # ignore autocorrelations
            if row.baseline[0]==row.baseline[1]:
                continue
            # in single-source files, row.source may not be present,
            # catching it
            try:
                source=row.source
            except KeyError:
                source=0
            #amp_RR=n.sqrt(row.visibility[0][:,0][:,0]**2 + row.visibility[0][:,0][:,1]**2)
            #amp_LL=n.sqrt(row.visibility[0][:,1][:,0]**2 + row.visibility[0][:,1][:,1]**2)
            #
            # When Aips data is flagged in UVCOP, weights are negated, but data are kept. Here, data is only copied
            # when weights are positive, otherwise amplitudes are set to -1
            # this fills an array upon a condition
            # n.where(condition, value_if_true, value_if_false)
            amp_RR=n.zeros((nchan*nif))
            amp_LL=n.zeros((nchan*nif))
            for j in range(nif):
                amp_RR[j*nchan:(j*nchan+nchan)]=n.where(row.visibility[j][:,0][:,2]>0.0, (n.sqrt(row.visibility[j][:,0][:,0]**2 + row.visibility[j][:,0][:,1]**2)), -1.0)
                amp_LL[j*nchan:(j*nchan+nchan)]=n.where(row.visibility[j][:,1][:,2]>0.0, (n.sqrt(row.visibility[j][:,1][:,0]**2 + row.visibility[j][:,1][:,1]**2)), -1.0)
            #print row
            #print "baseline:  ", row.baseline
            #print "visibility:", row.visibility
            #print "amp_RR:    ", amp_RR
            amp_I=(amp_RR+amp_LL)/2.0
            t=n.array([row.time, source])
            amp_I=n.hstack((t, amp_I))
            amp_RR=n.hstack((t, amp_RR))
            amp_LL=n.hstack((t, amp_LL))
            index="%i-%i" % (row.baseline[0], row.baseline[1])
            data_RR[index]=n.vstack((data_RR[index], amp_RR))
            data_LL[index]=n.vstack((data_LL[index], amp_LL))
            print ' Time, source ID, baseline, nvis: %s  %i  %5s  %i        \r' % (time2hms(86400*t[0]), source, index, data_RR[index].shape[0]),
        count=count+1
    print

    # put the data into a list so we can loop over it
    alldata=[data_RR, data_LL]

    if opts.usepickle != '' and not os.path.exists(opts.usepickle):
        file=open(opts.usepickle, 'w')
        cPickle.dump(alldata, file, 1)
        file.close()

    print " ...done."
else:
    print " Reading data from %s" % opts.usepickle
    file=open(opts.usepickle, 'r')
    alldata=cPickle.load(file)
    file.close()
    print " ...done."


# figure out integration time from some element in alldata
subdata=alldata[0][alldata[0].keys()[0]]
timediffs=n.diff(subdata[:,0])
inttime=n.median(timediffs)
print ' Integration time seems to be %.4fs' % (inttime*3600.0*24.0)
if n.isnan(inttime):
    inttime = 2.0
    print "Setting inttime to 2s, since it was NaN"

# some data needed for flag extension
# smoothing interval in seconds
shortsmooth=120.0 
shortwidth=int(round(shortsmooth/(inttime*3600.0*24.0)))
shortkernel=n.array([1]*shortwidth)
# convolution with this irons out small gaps
longsmooth=1200.0
longwidth=int(round(longsmooth/(inttime*3600.0*24.0)))
longkernel=n.array([1]*longwidth)
# acceptable fraction of RFI in long interval
longfrac=0.30

# figure out number of cores to use
ncpu=pprocess.get_number_of_cores()
nproc=max(1, ncpu-1)
print ' Using %i out of %i available cores for flagging' % (nproc, ncpu)

# loop over existing baselines
bsllist=alldata[0].keys()
bsllist.sort()

# fancy flagging just like in Pieflag
arglist=[]
for pol in range(2):
    for bsl in bsllist:
        # figure out antenna numbers and polarisation
        stokes=polnames[pol]
        # get the data
        subdata=alldata[pol][bsl]
        if subdata.shape[0]==0:
            print ' No data on this baseline, continuing.'
            continue
        print "appending data for polarisation %s, baseline %s to the 'to-be-processed' list" % (pol, bsl)
        arglist.append([subdata, bsl, pol])

#flagit([alldata[0]['9-12'], '9-12', 0])
#sys.exit()
#for row in arglist:
#    test=flagit(row)
#    for y in test[1]: print y
#    alldata[test[4]][test[3]]=test[2]

results=pprocess.pmap(flagit, arglist, limit=nproc)

# write flagging commands to disk
outfile=open(flagfile, 'a')

for x in results:
    commands=x[0]
    output=x[1]
    for y in commands:
        outfile.write(y)
    for y in output:
        print y

    # write data back into the main array
    #alldata[x[4]][x[3]]=x[2]

outfile.close()

# initialize a directory for the subplot properties
plots={}
    
# initialise the figure
fig=p.figure(figsize=(12,12))
fig.subplots_adjust(wspace=0.02, hspace=0.02)
fig.suptitle('Data from Aips file %s' % opts.aipsfile)

# get min and max for plots
if opts.minmax!='min,max':
    vmin=float(opts.minmax.split(',')[0])
    vmax=float(opts.minmax.split(',')[1])
    print " Found min, max = %2.1f, %2.1f for the colour transfer function" % (vmin, vmax)
else:
    maxamps=[]
    for pol in range(2):
	for ant in range(1, (len(uvdata.antennas)+1)):
	    for bsl in range((ant+1), (len(uvdata.antennas)+1)):
            
		# get the data and only do something if data exists for the actual baseline
		bslname="%i-%i" % (ant, bsl)
                data=alldata[pol][bslname][:,2:]
		try:
		    maxamps.append(data.max())
		except:
		    pass
    print " Maximum amplitudes per baseline and polarisation: "
    maxamps=n.array(maxamps)
    maxamps.sort()
    n.set_printoptions(precision=3)
    print maxamps
    lowerquarter=maxamps[:int(maxamps.size/4.0)]
    vmax=n.max(lowerquarter)
    print " Using lower quartile of maximum amplitudes (%.3e) as vmax" % vmax
    vmin=0.0


# make a colourful plot
for pol in range(2):
    for ant in range(1, (len(uvdata.antennas)+1)):
        for bsl in range((ant+1), (len(uvdata.antennas)+1)):
            
            # get the data and only do something if data exists for the actual baseline
            bslname="%i-%i" % (ant, bsl)
            data=alldata[pol][bslname]
            
            # create a masked array (ignoring flagged=negative data) to calculate mean and stddev
            masked_data=n.ma.masked_array(data[:,1:], data[:,1:]<0.0)
            #median.append([sigma, mean])
            output=''
            print " Now analysing baseline %s, polarisation %s" % (bslname, polnames[pol]),

            # do nothing when there is no data
            if data.shape[0]==0:
                output=output+"... no data found on this baseline"
            
            # when there is data, flag it if requested
            else:
                is_flagged=0
                reason=''

                # plotting can only be skipped if interactive mode is switched off and no plot is desired:
                if not (opts.noint and (not opts.makeplot)):
                    # determine the location of the subplot
                    # RR goes into the lower left triangle
                    if pol==0:
                        plotnum=ant+(bsl-1)*nant
                        output=output+"... subplot number %i" % plotnum
           
                        temp=p.subplot(nx, ny, plotnum)
                        plots[temp]=[plotnum, ant, bsl, pol]

                        # only plot labels at the edges of the diagram
                        if ant==1:
                            p.ylabel('%s Bsl %i' % (polnames[0], bsl), rotation=0)
                        if bsl==nant:
                            p.xlabel('%s Ant %i' % (polnames[0], ant), rotation=90)

                    # LL goes into the upper right triangle
                    else:
                        plotnum=bsl+(ant-1)*nant
                        output=output+"... subplot number %i" % plotnum

                        temp = p.subplot(nx, ny, plotnum)
                        plots[temp]=[plotnum, ant, bsl, pol]

                        temp.yaxis.set_label_position("right")
                        temp.xaxis.set_label_position("top")

                        if ant==1:
                            p.xlabel('%s Bsl %i' % (polnames[1], bsl), rotation=90)
                        if bsl==nant:
                            p.ylabel('%s Ant %i' % (polnames[1], ant), rotation=0)

                    # until I figure out how to draw tick labels only
                    # on the outer axes, no tick labels are drawn whatsoever
                    temp.xaxis.set_ticklabels([], visible=False)
                    temp.yaxis.set_ticklabels([], visible=False)


                    im = p.imshow(n.flipud(n.rot90(data[:,2:])), origin='lower', vmin=vmin, vmax=vmax, aspect='auto', interpolation='nearest')
                    #im = p.imshow(data[:,1:], origin='lower', vmin=vmin, vmax=vmax, aspect='auto')
                    #im = p.imshow(data[:,1:], origin='lower', aspect='auto')
                    fig.add_subplot(temp)
                print output



if opts.makeplot:
    print "\n Writing the hardcopy plot"
    fig.set_size_inches((nant*2,nant*2))
    p.savefig('%s.montage.png' % flagfile)


if not opts.noint:
    fig.set_size_inches((12,12))
    printhelp()
    cid = fig.canvas.mpl_connect('button_press_event', onclick)
    cld = fig.canvas.mpl_connect('key_press_event', on_key_event)

    p.show()

## Apply the flags
#vlbatasks.userflag(uvdata, 1, flagfile)


